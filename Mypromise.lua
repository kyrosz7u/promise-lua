---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by kyros.
--- DateTime: 2/27/23 6:03 PM
---

Promise = {
  PENDING = 'pending',
  FULFILLED = 'fulfilled',
  REJECTED = 'rejected'
}

Promise.__index = Promise

function Promise.new(excutor)
  local self = {}
  setmetatable(self, Promise)
  -- promise状态
  self.status=Promise.PENDING
  -- resolve回调函数
  self.resolvedQueues={}
  -- reject回调函数
  self.rejectedQueues={}

  local resolver= function(returned)
    if self.status==Promise.PENDING then
      self.returned = returned
      self.status = Promise.FULFILLED
      -- 遍历执行回调函数
      for _, callback in pairs(self.resolvedQueues) do
        callback(self.returned)
      end
    end
  end

  local rejected = function(error)
    if self.status==Promise.PENDING then
      self.error = error
      self.status = Promise.REJECTED
      -- 遍历执行回调函数
      for _, callback in pairs(self.rejectedQueues) do
        callback(self.error)
      end
    end
  end

  local ok, result = pcall(excutor, resolver, rejected)
  if not ok then
    rejected(result)
  end

  return self
end

function Promise:andThen(onFulfilled, onRejected)
  -- a and b or c 等价于C语言的 a ? b : c
  onFulfilled = type(onFulfilled)=="function" and onFulfilled
    or function(returned) return returned end

  onRejected = type(onRejected)=="function" and onRejected
    or function(error)  return error end
  
  -- 实现andThen链式调用, 让promise2传递onFulfilled和onRejected的执行结果
  Promise2 = Promise.new(function (resolve, reject)
    if self.status== Promise.PENDING then
      table.insert(self.resolvedQueues, function (returned)
        local ok, x = pcall(onFulfilled, returned)
        return ok and ResolvePromise(Promise2, x, true, resolve, reject) or reject(x)
    end)
      table.insert(self.rejectedQueues, function (error)
        local ok, x = pcall(onRejected, error)
        return ok and ResolvePromise(Promise2, x, false, resolve, reject) or reject(x)
      end)
        
    elseif self.status== Promise.FULFILLED then
      local ok, x = pcall(onFulfilled, self.returned)
      return ok and ResolvePromise(Promise2, x, true, resolve, reject) or reject(x)

    elseif self.status== Promise.REJECTED then
      local ok, x = pcall(onRejected, self.error)
      return ok and ResolvePromise(Promise2, x, false, resolve, reject) or reject(x)
    end
  end)
  return Promise2
end

function ResolvePromise(p2, x, isResolve, resolve, reject)
  if x ~= nil and x==p2 then
    return reject('p2 must not equal to x')
  end
  -- 判断返回值的是不是Promise对象
  if type(x) == 'table' and getmetatable(x) == Promise then
    if x.status==Promise.PENDING then
      x:andThen(function (y)
        ResolvePromise(p2, y, true, resolve, reject)
      end, function (error)
        reject(error)
      end)
    end
  else
    return isResolve and resolve(x) or reject(x)
  end
end

function Promise:catch(onRejected)
  return self:andThen(nil, onRejected)
end

function Promise:finally(final)
  return self:andThen(final, final)
end

function Promise.all(promises)
  return Promise.new(function (resolve, reject)
    local ret = {}

    for i=1, #promises do
      promises[i]:andThen(
        function (returned)
          ret[i] = returned
          if i >= #promises - 1 then
            resolve(ret)
          end
        end, function (error)
          reject(error)
        end
      )
    end
    
  end)
end

function Promise.race(promises)
  return Promise.new(function (resolve, reject)
    for i=1, #promises do
      promises[i]:andThen(resolve, reject)
    end
  end)
end

function Promise.resolve(val)
  return Promise.new(function (resolve, reject)
    resolve(val)
  end)
end

function Promise.reject(val)
  return Promise.new(function (resolve, reject)
    reject(val)
  end)
end

